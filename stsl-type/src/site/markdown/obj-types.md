Объектные типы
=======================

Типы данных можно разделить на несколько категорий:

- Простые типы данных: числа, булево (true/false), буквы, ...
- Составные типы данных: строка букв, комбинации строк - ФИО и т.д.
- Специальные типы данных

Простые типы определены в [xyz.cofe.stsl.tast.JvmType](https://github.com/gochaorg/stsl/blob/94ca7518f9850c28c1a214f24771e35e778c734d/stsl-parser/src/main/scala/xyz/cofe/stsl/tast/JvmType.scala):

- `BOOLEAN` Булево - может принимать значение `true` и `false`
- `NUMBER` - Число
- `BYTE` - Частный случай числа - 1 байт, целое число, может принимать от -128 до +127 
- `INT` - Частный случай числа - 4 байта, целое число, может принимать от -2,147,483,648 до 2,147,483,647
- `LONG` - Частный случай числа - 8 байта, целое число, может принимать от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807
- `CHAR` - Буква, unicode 16, 2 байта
- `STRING` - Строка символов (букв), unicode

Здесь написаны не все типы которые определены в файле [JvmType](https://github.com/gochaorg/stsl/blob/94ca7518f9850c28c1a214f24771e35e778c734d/stsl-parser/src/main/scala/xyz/cofe/stsl/tast/JvmType.scala)

**Можно определить свой набор простых типов**, 
совсем не обязательно пользоваться заданным набором

Описание типа Boolean
-----------------------------

Рассмотрим пример с `boolean`

Допустим у нас есть операция логическое И, 
сама операция применяется для двух значений и обозначается через амперсанд `&`.

Вот пример ее использования в любом типичном языке программирования

    a & b

где `a` и `b` - это значения 

Обычно для операции И в учебниках по мат логике расписывают вот такую [таблицу истинности](https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D0%B8%D1%81%D1%82%D0%B8%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8) 

| значение-а | значение-б | результат-И |
|------------|------------|-------------|
| **true**   | **true**   | **true**    |
| false      | **true**   | false       |
| **true**   | false      | false       |
| false      | false      | false       |

В языке Java, Scala данная операция определена как `&&` и имеет то же значение, что и приведенная таблица выше.

Данный оператор можно представить как функцию от двух аргументов - пример:

```java
boolean and( boolean a, boolean b ){ return a && b; }
```

Ее использование в немного отличается от использования оператора напрямую, но суть та же

```java
and( a, b )
```

Определим свой тип BOOLEAN и операции, псевдокод на языке Java будет такой:

```java
class BOOLEAN {
    public final boolean value;
    public BOOLEAN( boolean initital ){ value = initital; }
    public BOOLEAN and( BOOLEAN v ){ return new BOOLEAN( value && v.value ); }
    public BOOLEAN or( BOOLEAN v ){ return new BOOLEAN( value || v.value ); }
    public BOOLEAN not(){ return new BOOLEAN( !value ); }
}
```

Данная библиотека не опирается на средства рефлексии JVM ([java.lang.reflect.*](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html)) и одна из ее целей - проверка корректности типов в том или ином языке.

Соответственно, чтоб описать тип BOOLEAN при помощи данной библиотеки надо будет написать примерно такой код (Scala):

```scala
// Опеределяем тип BOOLEAN, который называется как bool
val BOOLEAN: TObject = new TObject("bool")

// Данный тип разширяет бзовый тип - ANY
BOOLEAN.extend(ANY)

// Для данного типа определяем метод/оператор ! - логическое НЕ
BOOLEAN.methods += "!" -> Fn(
  // Данный метод принимает параметры
  Params(
    // Первый и единственный параметр - ссылка на объект типа BOOLEAN
    "self" -> Type.THIS
  ),
  
  // Данный метод - возвращает - тип самого себя - т.е. BOOLEAN 
  Type.THIS
  
).invoke[Boolean,Boolean](
  // А это непосредственно реализация оператора ! для данного типа объектов
  self => !self
)

// Для данного типа определяем метод/оператор && - логическое И
BOOLEAN.methods += "&&" -> Fn(
  // Данный метод принимает 2 параметра
  Params(
    // Первый параметр - ссылка на первое значение, объект типа BOOLEAN
    "self" -> THIS,

    // Второй параметр - ссылка на второе значение, объект типа BOOLEAN
    "value" -> THIS
  ),

  // Данный метод - возвращает - тип самого себя - т.е. BOOLEAN
  Type.THIS
).invoke[Boolean,Boolean,Boolean](
  // Реализация оператора && для данного типа объектов
  (self,value)=>self && value
)

// Для данного типа определяем метод/оператор || - логическое ИЛИ
BOOLEAN.methods += "||" -> Fn(
  // Данный метод принимает 2 параметра
  Params(
    // Первый параметр - ссылка на первое значение, объект типа BOOLEAN
    "self" -> Type.THIS,

    // Второй параметр - ссылка на второе значение, объект типа BOOLEAN
    "value" -> Type.THIS
  ),

  // Данный метод - возвращает - тип самого себя - т.е. BOOLEAN
  Type.THIS
).invoke[Boolean,Boolean,Boolean](
  // Реализация оператора || для данного типа объектов
  (self,value)=>self || value
)
```

В данном примере, BOOLEAN - это переменная, 
которая описывает тип данных и как с ним можно работать.

Для такой переменной можно посмотреть описание, например так

```scala
println(TypeDescriber.describe(JvmType.BOOLEAN))
```

На экран будет выведено примерно такое содержание:

    bool extends any {
      !  (self:THIS):THIS
      && (self:THIS, value:THIS):THIS
      || (self:THIS, value:THIS):THIS
      /* extends any */
    }

В данном случае

- `bool` - это то имя, которое мы дали программным путем
- `! (...)` - это функция которая определена в типе
- `self, value` - это имена пераметров функции
- `THIS` - это специальный тип, который обозначает САМ тип, в данном случае это `bool`
- `extends any` - это указывает на [родительский тип](extendable.md) - `any`
- `/* extends any */` - комментарий говорящий, что дальше будут указаны 
    [унаследованные функции/методы/свойства](extendable.md) от типа `any`
  
Фактически необходимо заменить тип `THIS`, на `bool`, 
и при проверках допустимости операций, такая замена выполняется автоматически.

В результате операции замены, тип будет представлен так:

    bool extends any {
      !  (self:bool):bool
      && (self:bool, value:bool):bool
      || (self:bool, value:bool):bool
      /* extends any */
    }

Описание пользовательского типа
-------------------------------------

Допустим у нас есть тип Person

```java
public static class Person {
    public String name;
    public int age;
    public Person(){}
    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    public boolean allow( String actionName ){
        if( actionName==null )return false;
        return actionName.length()>3;
    }
}
```

Для описания его мы можем воспользоваться данной библиотекой.
Вот так это будет (Java):

```java
// Здесь мы объявляем тип Person, и декларируем "поля" данного класса - fields()
public TObject personType = TObject.create("Person").fileds( fieldsBuilder -> {
    fieldsBuilder
        // Указываем поле name типа STRING
        .fileld("name", JvmType.STRING())
        // А так же реализацию чтения и записи этого поля
        .writeable(
            // Функция чтения
            obj -> ((Person)obj).name,
            // Функция записи
            (obj,value) -> ((Person)obj).name = (String)value )
        // Добавляем это поле в тип Person
        .add()
        // Указываем поле age типа INT
        .fileld("age", JvmType.INT())
        // А так же реализацию чтения и записи этого поля
        .writeable(
            // Функция чтения
            obj -> ((Person)obj).age,
            // Функция записи
            (obj,value) -> ((Person)obj).age = (int)value )
        // Добавляем это поле в тип Person
        .add();
// Еще опишем методы данного класса
}).methods( methodsBuilder -> {
    // Создаем описание метода
    methodsBuilder.method( mbuilder -> {
        mbuilder
            // Имя метода - allow
            .name("allow")
            // Типы параметров
            .params( param -> param.param("obj", Type.THIS()).param("name", JvmType.STRING()) )
            // Возвращаемый тип данных
            .result( JvmType.BOOLEAN() )
            // Добавляем реализацию для данного метода
            .callable( args -> ((Person)args.get(0)).allow((String)args.get(1)) )
            // Добавляем сконструированный метод в тип Person
            .add()
        ;
    });
// Создаем тип по описанию
}).build();

// Замораживаем тип так, что бы 
// нельзя было его в дальнейшем модифицировать
{ personType.freeze(); }
```

Посмотреть описание этого типа, можно так же:

```java
System.out.println(TypeDescriber.describe(personType));
```

Вывод

    Person extends any {
      name : string
      age : int
      allow(obj:THIS,name:string):bool
      /* extends any */
    }

Первый итог
--------------------

- Хоть и у нас есть в разных языках номинальные простые типы (boolean,number,int,...)
  по факту их можно представить как объекты, которые содержат методы работы над ними
- Операторы используемые в том или ином языке, являются по сути функциями принимающие 
  значения определенного типа и возвращающие значения определенного типа
- Отличие методов от функций, по факту не существенно, только наличием передачи в явном или не явном виде ссылке на объект, обычно такая ссылка называется `this` в разных
    - В java, javascript, C#, ... такая переменная передается в неявной форме
    - В python - в явной форме, через аргумент `self`
- Отличие объектов от примитивных значений - то же не значительно
    - В примитивных значениях нет внутренних значений, примитивное значение конечно по своей сути
    - Объектные типы - обычно содержит в себе другие объекты и/или примитивные значения
    
Разберем тезисы первого итога

### Номинальные простые типы

_Номинальные простые типы_ - т.е. такие типы данных которые имеют название (номинальность).

_Над простыми типами данных_ (и не только простыми) возможны операции, которые по сути выражаются как функции

Пример: число это тип данных, а функции над числами:

- сложение `a + b` (переписать в виде вызова функции например так `+(a,b)`), 
- вычитание `a - b`,
- деление `a / b`, 
- умножение `a * b`, 
- инверсия знака `-a`, 
- Операции сравнения, результат сравнения обычно носит тип `boolean`
    - сравнение на равенство `a == b`
    - сравнение на не равенство `a != b`,
    - сравнение на больше `a > b`,
    - сравнение на больше или равно `a >= b`,
    - сравнение на меньше  `a < b`,
    - сравнение на меньше или равно  `a <= b`,
    
Такие функции принято называть операторами

### Отличие методов от функций, по факту не существенно

Формально в языке Python вызов метода объекта записывается так:
`object.method1(arg1,arg2)`

Что по сути сводиться к вызову функции `method1`, c такими аргументами: `method1(object,arg1,arg2)`

Две эти конструкции равнозначны, и такая же логика применима в других языках программирования,
где-то реализовано в явной форме (Python), а где-то в неявной (Java)

### В примитивных значениях нет внутренних значений

Примитивные значения являются базой для построения более сложных типов данных 
и как правило определяются тем или иным языком программирования.

Список этих типов невозможно расширить (уменьшить) для конкретного языка, 
без модификации самого языка.

Как правило, эти типы связаны между собой через операторы этого языка.

Примитивный тип может представлять конкретную особенность архитектуры компьютера, 
например в языке Byte - это всегда число, цело и содержит в себе 8 бит информации.

А в языке JavaScript - нет такого типа данных как Byte, есть number и другие типы, 
но Byte как часть спецификации языка нет.

Примитивные типы данных - как правило атомарны, 
в смысле не делимы на более примитивные типы данных.