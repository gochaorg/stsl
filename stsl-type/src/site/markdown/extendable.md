Наследственность
=======================

Тезис 2 - Все люди животные, но не все животные люди
----------------------------------------------------

Рассмотрим пример, допустим у нас есть несколько множеств:

- Прокариоты (одноклеточные)
- Эукариоты (многоклеточные)
    - Гребневики
    - Стрекающие
    - Двусторонне-симметричные
        - Первичноротые
        - Вторичноротые
            - Хордовые

Можно заметить что перечислены разные живые существа, 
при том что свойства дочерних наследуют свойства родительских существу.

Дочернее животное имеет свойства от родительского и добавляет 
какие-то свои дополнительные свойства.

Описание свойств приведено в [разделе Объектные типы](obj-types.md).

Другой пример, у нас есть несколько типов чисел:

- Натуральное число (1, 2, 3, 4, 5, 6, 7 и так далее...)
- Целые числа (..,-3,-2,-1,0,1,2,3,...)
- Рациональные числа ( 2/5, 3/4 )
- Действительные числа
- Комплексные числа

И между перечисленными типами числами есть опеределенные зависимости и наследуемые свойства.

Например все целые числа, так же являются натуральными, но не является рациональными (дробями).

А свойства чисел, то что их можно:

- например складывать и мы получим числа того же типа, что и были в процессе сложения.
- некоторые операции, например кроме сложения и умножения, могут привести к 
  таким числам которые не могут выражены в тем же типом чисел, т.е. 
  например операция деления целых чисел ведет к рациональным числам.
  
В отношении типов данных, ключевым моментом является **какие операции можно 
производить над этими типами, а какие нельзя,** 
и как следствие какой тип данных мы получим от этих операций.

number: int, double
---------------------------------------
 
### Математические свойства алгебры

Например для чисел можно [определить следующие операции](obj-types.md): сложение (+), вычитание (-), умножение (*), деление (/), сравнение на равенство

```java
abstract class Number {
    public abstract Number add( Number o );
    public abstract Number sub( Number o );
    public abstract Number mul( Number o );
    public abstract Number div( Number o );
    public abstract boolean equals( Number o );
}
```

Но сами по себе числа, должны быть привязаны к архитектуре компьютера на котором они используется, в явной форме (программистом) или не явной форме (компилятором)

Мы можем реализовать эту абстракцию как: 

- 1 байту: ByteNumber,
- 2 байтам: ShortNumber,
- 4 байтам: IntNumber,
- 8 байтам: LongNumber,
- 16 байтам: LongLongNumber,
- ...

С точки зрения математики/алгоритмов нам может быть не важна конечная реализация чисел
и выбор того или иного типа чисел мы можем руководствоваться кол-вом свободной оперативной памяти
и точности результата

Главным условием для конечной реализации, чтоб соблюдались свойства математических операций.

Например таких, как:

Для операции сложения (add) не важен порядок аргументов передаваемых в функцию сложения,
иначе говоря 

`a + b = b + a`

или же оно в коде

```java
Number a = ..
Number b = ..
Number r1 = a.add( b )
Number r2 = b.add( a )
r1.equals( r2 )
r2.equals( r1 )
```

т.е. перестановка аргументов не влияет на результат, тогда в конечных реализациях это свойство должно сохраняться.

Пример с типами boolean, string, number
---------------------------------------

**string**

Строки - это такой тип данных как массив букв из которого складывается текст.

Как правило, минимальный набор операций над строками можно выделить следующий:

- Определение длины строки - кол-ва символом.
    - для строки `"hello"` - значение должно быть число `5`, при том целое.
- Получить символ сроки или подстроки в заданной позиции.
    - для строки `"hello"` - необходимо например получить строку, начиная с первого символа, 4 символа - результат `"hell"`
- Конкатенация строк - образование новой строки из прибавления к концу строки, другой строки.
    - для строки `"hell"` присоединить строку `"o"`, в результате должно быть строка `"hello"`